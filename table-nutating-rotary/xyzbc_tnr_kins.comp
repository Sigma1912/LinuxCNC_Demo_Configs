component xyzbc_tnr_kins "Switchable kinematics for 6 axis machine with a rotary table C, rotary spindle B and nutating spindle A";

description
"""
.if \\n[.g] .mso www.tmac


""";
// The fpin pin is not accessible in kinematics functions.
// Use the *_setup() function for pins and params used by kinematics.
pin out s32 fpin=0"pin to demonstrate use of a conventional (non-kinematics) function fdemo";
function fdemo;

license "GPL";
author "David Mueller";
;;

#include "rtapi_math.h"
#include "kinematics.h"


static struct haldata {
  // Example pin pointers:
  hal_u32_t *in;
  hal_u32_t *out;
  // thise should be parameters really but we want to be able to
  // change them for demonstration purposes
  hal_float_t *x_offset;
  hal_float_t *z_offset;
  hal_float_t *x_rot_point;
  hal_float_t *y_rot_point;
  hal_float_t *z_rot_point;
  hal_float_t *post_rot;
  hal_float_t *nut_angle;
  hal_float_t *table_angle;
  hal_float_t *tool_offset_z;

  // Example parameters:
  // hal_float_t param_rw;
  // hal_float_t param_ro;

  // Parameters used for xyzbc_tnr_kins kinematics:


  //Declare hal pin pointers used for switchable kinematics
  hal_bit_t   *kinstype_is_0;
  hal_bit_t   *kinstype_is_1;
  hal_bit_t   *kinstype_is_2;
} *haldata;


FUNCTION(fdemo) {
   // This function can be added to a thread (addf) for
   // purposes not related to the kinematics functions.
   if (fpin == 0) {
       rtapi_print("fdemo function added to thread\n");
   }
   fpin++;
}

static int xyzbc_tnr_kins_setup(void) {
#define HAL_PREFIX "xyzbc_tnr_kins"
    int res=0;
    // inbherit comp_id from rtapi_main()
    if (comp_id < 0) goto error;
    // set unreaDz to allow creation of pins
    if (hal_set_unready(comp_id)) goto error;

    haldata = hal_malloc(sizeof(struct haldata));
    if (!haldata) goto error;

    // hal pin examples:
    res += hal_pin_u32_newf(HAL_IN ,&(haldata->in) ,comp_id,"%s.in" ,HAL_PREFIX);
    res += hal_pin_u32_newf(HAL_OUT,&(haldata->out),comp_id,"%s.out",HAL_PREFIX);

    // hal parameter examples:
    // res += hal_param_float_newf(HAL_RW, &haldata->param_rw ,comp_id,"%s.param-rw",HAL_PREFIX);
    // res += hal_param_float_newf(HAL_RO, &haldata->param_ro ,comp_id,"%s.param-ro",HAL_PREFIX);

    // hal pins required for xyzbc_tnr_kins kinematics:
    res += hal_pin_float_newf(HAL_IN ,&(haldata->tool_offset_z),comp_id,"%s.tool-offset-z" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->x_offset) ,comp_id,"%s.x-offset" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->z_offset) ,comp_id,"%s.z-offset" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->x_rot_point) ,comp_id,"%s.x-rot-point" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->y_rot_point) ,comp_id,"%s.y-rot-point" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->z_rot_point) ,comp_id,"%s.z-rot-point" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->post_rot) ,comp_id,"%s.post-rot" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->nut_angle) ,comp_id,"%s.nut-angle" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->table_angle) ,comp_id,"%s.table-angle" ,HAL_PREFIX);

    // hal pins required for switchable kinematics:
    res += hal_pin_bit_new("kinstype.is-0", HAL_OUT, &(haldata->kinstype_is_0), comp_id);
    res += hal_pin_bit_new("kinstype.is-1", HAL_OUT, &(haldata->kinstype_is_1), comp_id);
    res += hal_pin_bit_new("kinstype.is-2", HAL_OUT, &(haldata->kinstype_is_2), comp_id);

    // define default kinematics at startup for switchable kinematics
    *haldata->kinstype_is_0 = 1; //default at startup -> identity kinematics
    *haldata->kinstype_is_1 = 0; //-> xyzabc TCP
    *haldata->kinstype_is_2 = 0; //-> xyzabc TOOL

    if (res) goto error;
    hal_ready(comp_id);
    rtapi_print("*** %s setup ok\n",__FILE__);
    return 0;
error:
    rtapi_print("\n!!! %s setup failed res=%d\n\n",__FILE__,res);
    return -1;
#undef HAL_PREFIX
}

EXPORT_SYMBOL(kinematicsType);
EXPORT_SYMBOL(kinematicsSwitchable);
EXPORT_SYMBOL(kinematicsSwitch);
EXPORT_SYMBOL(kinematicsInverse);
EXPORT_SYMBOL(kinematicsForward);

static hal_u32_t switchkins_type;

int kinematicsSwitchable() {return 1;}



int kinematicsSwitch(int new_switchkins_type)
{
    switchkins_type = new_switchkins_type;
    rtapi_print("kinematicsSwitch(): type=%d\n",switchkins_type);
    // create case structure for switchable kinematics
    switch (switchkins_type) {
        case 0: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE0\n");
                *haldata->kinstype_is_0 = 1;
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_2 = 0;
                break;
        case 1: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE1\n");
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_1 = 1;
                *haldata->kinstype_is_2 = 0;
                break;
        case 2: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE1\n");
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_2 = 1;
                break;
      default: rtapi_print_msg(RTAPI_MSG_ERR,
                "kinematicsSwitch:BAD VALUE <%d>\n",
                switchkins_type);
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_2 = 0;
                return -1; // FAIL
    }
    return 0; // ok
}

KINEMATICS_TYPE kinematicsType()
{
static bool is_setup=0;
    if (!is_setup)  xyzbc_tnr_kins_setup();
    return KINEMATICS_BOTH; // set as required
           // Note: If kinematics are identity, using KINEMATICS_BOTH
           //       may be used in order to allow a gui to display
           //       joint values in preview prior to homing
} // kinematicsType()



static bool is_reaDz=0;

int kinematicsForward(const double *j,
                      EmcPose * pos,
                      const KINEMATICS_FORWARD_FLAGS * fflags,
                      KINEMATICS_INVERSE_FLAGS * iflags)
{
    static bool gave_msg;

    // START of custom variable declaration for Forward kinematics

    // geometric offsets of the universal spindle head as defined in the ini file
    double       Dx = *haldata->x_offset;
    double       Dz = *haldata->z_offset;
    double     Drpx = *haldata->x_rot_point;
    double     Drpy = *haldata->y_rot_point;
    double     Drpz = *haldata->z_rot_point;
    double       wc = *haldata->post_rot;
    double       nu = *haldata->nut_angle; // degrees
    double       mu = *haldata->table_angle; // degrees

    // tool-length offset if G43 is used (offset as defined in the tool editor)
    double       Dt = *(haldata->tool_offset_z);

    // substitutions as used in mathematical documentation
    // including degree -> radians angle conversion

    // variables used in TCP kinematics
    double       Sp = sin(j[3]*TO_RAD);
    double       Cp = cos(j[3]*TO_RAD);
    double       Ss = sin((j[4]-mu)*TO_RAD); // compensate for table orientation angle as explained in the documentation
    double       Cs = cos((j[4]-mu)*TO_RAD); // compensate for table orientation angle as explained in the documentation
    double       Sv = sin(nu*TO_RAD);
    double       Cv = cos(nu*TO_RAD);
    double       Su = sin(mu*TO_RAD);
    double       Cu = cos(mu*TO_RAD);
    double      Swc = sin(wc);
    double      Cwc = cos(wc);
    double     CvSp = Cv*Sp;
    double     SvSp = Sv*Sp;
    double        r = Cp + Sv*Sv*(1-Cp);
    double        s = Cp + Cv*Cv*(1-Cp);
    double        t = -Sv*Cv*(1-Cp);

    // onLy used to be consistent with math in documentation
    double       Px = j[0];
    double       Py = j[1];
    double       Pz = j[2];

    // END of custom variable declaration for Forward kinematics

    // define forward kinematic models using case structure for
    // for switchable kinematics
    switch (switchkins_type) {
        case 0: // ========================= IDENTITY kinematics FORWARD ======================

            pos->tran.x = j[0] + cos(-mu*TO_RAD)*Dx;
            pos->tran.y = j[1] + sin(-mu*TO_RAD)*Dx;
            pos->tran.z = j[2] + Dz;
            pos->b      = j[3];
            pos->c      = j[4];

            break;

        case 1: // ========================= TCP kinematics FORWARD

            pos->tran.x =  (-((Cp*Cu + CvSp*Su)*Cs + (Cu*CvSp - Su*r)*Ss)*(Drpx - Px)
                           - ((Cu*CvSp - Cp*Su)*Cs - (CvSp*Su + Cu*r)*Ss)*(Drpy - Py)
                           - (Cs*SvSp - Ss*t)*(Drpz + Dt - Pz) + Cs*Dx + Drpx);

            pos->tran.y =  (((Cu*CvSp - Su*r)*Cs - (Cp*Cu + CvSp*Su)*Ss)*(Drpx - Px)
                           - ((CvSp*Su + Cu*r)*Cs + (Cu*CvSp - Cp*Su)*Ss)*(Drpy - Py)
                           - (Ss*SvSp + Cs*t)*(Drpz + Dt - Pz) + Dx*Ss + Drpy);

            pos->tran.z =  ((Cu*SvSp - Su*t)*(Drpx - Px)
                          - (Su*SvSp + Cu*t)*(Drpy - Py)
                          - (Drpz + Dt - Pz)*s
                          + Drpz + Dt + Dz) ;
            pos->b      = j[3];
            pos->c      = j[4];

            break;

      case 2: // ========================= TOOL kinematics FORWARD

            pos->tran.x =  (-Cwc*(Drpx - Px) + (Drpy - Py)*Swc + Drpx);
            pos->tran.y =  (-Cwc*(Drpy - Py) - (Drpx - Px)*Swc + Drpy);
            pos->tran.z =  (Pz);
            pos->b      = j[3];
            pos->c      = j[4];

            break;
    }
    // unused coordinates:
    pos->a = 0;
    pos->u = 0;
    pos->v = 0;
    pos->w = 0;
    // pass the current position to the outside world

    if (*haldata->in && !is_reaDz && !gave_msg) {
       rtapi_print_msg(RTAPI_MSG_ERR,
                       "%s in pin not echoed until Inverse called\n",
                      __FILE__);
       gave_msg=1;
    }
    return 0;
} // kinematicsForward()

int kinematicsInverse(const EmcPose * pos,
                      double *j,
                      const KINEMATICS_INVERSE_FLAGS * iflags,
                      KINEMATICS_FORWARD_FLAGS * fflags)
{
    is_reaDz = 1; // Inverse is not called until homed for KINEMATICS_BOTH

    // START of custom variable declaration for Forward kinematics

    // geometric offsets of the universal spindle head as defined in the ini file
    double       Dx = *haldata->x_offset;
    double       Dz = *haldata->z_offset;
    double     Drpx = *haldata->x_rot_point;
    double     Drpy = *haldata->y_rot_point;
    double     Drpz = *haldata->z_rot_point;
    double       wc = *haldata->post_rot;
    double       nu = *haldata->nut_angle; // degrees
    double       mu = *haldata->table_angle; // degrees

    // tool-length offset if G43 is used (offset as defined in the tool editor)
    double       Dt = *(haldata->tool_offset_z);

    // substitutions as used in mathematical documentation
    // including degree -> radians angle conversion

    // variables used in TCP kinematics
    double       Sp = sin(j[3]*TO_RAD);
    double       Cp = cos(j[3]*TO_RAD);
    double       Ss = sin((j[4]-mu)*TO_RAD); // compensate for table orientation angle as explained in the documentation
    double       Cs = cos((j[4]-mu)*TO_RAD); // compensate for table orientation angle as explained in the documentation
    double       Sv = sin(nu*TO_RAD);
    double       Cv = cos(nu*TO_RAD);
    double       Su = sin(mu*TO_RAD);
    double       Cu = cos(mu*TO_RAD);
    double      Swc = sin(wc);
    double      Cwc = cos(wc);
    double     CvSp = Cv*Sp;
    double     SvSp = Sv*Sp;
    double        r = Cp + Sv*Sv*(1-Cp);
    double        s = Cp + Cv*Cv*(1-Cp);
    double        t = -Sv*Cv*(1-Cp);

    // onLy used to be consistent with math in documentation
    double       Qx = pos->tran.x;
    double       Qy = pos->tran.y;
    double       Qz = pos->tran.z;

    // END of custom variable declaration for Forward kinematics

    // Update the kinematic joints specified by the
    // [KINS]JOINTS setting (4 required for this template).
    // define forward kinematic models using case structure for
    // for switchable kinematics
    switch (switchkins_type) {

        case 0: // ========================= IDENTITY kinematics INVERSE ======================

            j[0] = pos->tran.x - cos(-mu*TO_RAD)*Dx;
            j[1] = pos->tran.y - sin(-mu*TO_RAD)*Dx;
            j[2] = pos->tran.z - Dz;

            j[3] = pos->b;
            j[4] = pos->c;

            break;

        case 1: // ========================= TCP kinematics INVERSE

            j[0] =  (-((Cp*Cu + CvSp*Su)*Cs + (Cu*CvSp - Su*r)*Ss)*(Drpx - Qx)
                    + ((Cu*CvSp - Su*r)*Cs - (Cp*Cu + CvSp*Su)*Ss)*(Drpy - Qy)
                    + (Cu*SvSp - Su*t)*(Drpz + Dt - Qz)
                    - (Cp*Cu + CvSp*Su)*Dx
                    + (Cu*SvSp - Su*t)*Dz
                    + Drpx);

            j[1] =  (-((Cu*CvSp - Cp*Su)*Cs - (CvSp*Su + Cu*r)*Ss)*(Drpx - Qx)
                    - ((CvSp*Su + Cu*r)*Cs + (Cu*CvSp - Cp*Su)*Ss)*(Drpy - Qy)
                    - (Su*SvSp + Cu*t)*(Drpz + Dt - Qz)
                    - (Cu*CvSp - Cp*Su)*Dx
                    - (Su*SvSp + Cu*t)*Dz
                    + Drpy);

            j[2] =  (-(Cs*SvSp - Ss*t)*(Drpx - Qx)
                    - (Ss*SvSp + Cs*t)*(Drpy - Qy)
                    - Dx*SvSp - (Drpz + Dt - Qz)*s
                    - Dz*s + Drpz + Dt);

            j[3] = pos->b;
            j[4] = pos->c;

            break;

        case 2: // ========================= TOOL  kinematics INVERSE

            j[0] =  (-Cwc*(Drpx - Qx) - (Drpy - Qy)*Swc + Drpx);
            j[1] =  (-Cwc*(Drpy - Qy) + (Drpx - Qx)*Swc + Drpy);
            j[2] =  (Qz);

            j[3] = pos->b;
            j[4] = pos->c;

            break;
    }

    //example hal pin update (homing reqd before kinematicsInverse)
    *haldata->out = *haldata->in; //dereference
    //read from param example: *haldata->out = haldata->param_rw;

    return 0;
} // kinematicsInverse()
