component  mazak_integrex_200y_kins "Switchable kinematics for 5 axis lathe machine with tool rotation B and virtual Y";

description
"""

This is a switchable kinematics module for a 5-axis lathe/milling configuration
using 3 cartesian linear joints (XYZ) and 2 rotary table joints (AB).

The module contains two kinematic models:

type0 (default) is a trivial XYZAB configuration with joints 0..4 mapped to
axes XYZAB respectively.

type1 is a XYZAB configuration with tool center axis (TCP) compensation.


.if \\n[.g] .mso www.tmac
""";

pin out s32 dummy=0"one pin needed to satisfy halcompile requirement";

license "GPL";
author "David Mueller";
;;

#include "rtapi_math.h"
#include "kinematics.h"

static struct haldata 
{
  // Declare hal pin axisers used for xyzab_tdr kinematics:
  hal_float_t *tool_offset_x;
  hal_float_t *tool_offset_y;
  hal_float_t *tool_offset_z;
  hal_float_t *x_pivot;
  hal_float_t *z_offset;
  hal_float_t *x_rot_axis;
  hal_float_t *y_rot_axis;
  hal_float_t *y_yt_angle;
  hal_float_t *tool_angle;
  hal_float_t *b_orientation;
  hal_float_t *work_angle;
  hal_float_t *prerot_angle;

  //Declare hal pin axisers used for switchable kinematics
  hal_bit_t   *kinstype_is_0;
  hal_bit_t   *kinstype_is_1;
  hal_bit_t   *kinstype_is_2;
  hal_bit_t   *kinstype_is_3;
} *haldata;

static int MAZAK_setup(void) 
{
	#define HAL_PREFIX "mazak-integrex-200y-kins"
    int res=0;
    // inherit comp_id from rtapi_main()
    if (comp_id < 0) goto error;
    // set unready to allow creation of pins
    if (hal_set_unready(comp_id)) goto error;

    haldata = hal_malloc(sizeof(struct haldata));
    if (!haldata) goto error;

    // hal pins required for xyzab_tdr kinematics:
    res += hal_pin_float_newf(HAL_IN ,&(haldata->tool_offset_x) 	,comp_id,"%s.tool-offset-x" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->tool_offset_y) 	,comp_id,"%s.tool-offset-y" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->tool_offset_z) 	,comp_id,"%s.tool-offset-z" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->x_pivot) 			,comp_id,"%s.x-pivot" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->z_offset) 			,comp_id,"%s.z-offset" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->x_rot_axis) 		,comp_id,"%s.x-rot-axis" ,HAL_PREFIX);
    res += hal_pin_float_newf(HAL_IN ,&(haldata->y_rot_axis) 		,comp_id,"%s.y-rot-axis" ,HAL_PREFIX);
	res += hal_pin_float_newf(HAL_IN ,&(haldata->y_yt_angle) 		,comp_id,"%s.y-yt-angle" ,HAL_PREFIX);
	res += hal_pin_float_newf(HAL_IN ,&(haldata->tool_angle) 		,comp_id,"%s.tool-angle" ,HAL_PREFIX);
	res += hal_pin_float_newf(HAL_IN ,&(haldata->b_orientation) 	,comp_id,"%s.b-orientation" ,HAL_PREFIX);
	res += hal_pin_float_newf(HAL_IN ,&(haldata->work_angle) 		,comp_id,"%s.work-angle" ,HAL_PREFIX);
	res += hal_pin_float_newf(HAL_IN ,&(haldata->prerot_angle)      ,comp_id,"%s.prerot-angle" ,HAL_PREFIX);
	
    // hal pins required for switchable kinematics:
    res += hal_pin_bit_new("kinstype.is-0", HAL_OUT, &(haldata->kinstype_is_0), comp_id);
    res += hal_pin_bit_new("kinstype.is-1", HAL_OUT, &(haldata->kinstype_is_1), comp_id);
    res += hal_pin_bit_new("kinstype.is-2", HAL_OUT, &(haldata->kinstype_is_2), comp_id);
    res += hal_pin_bit_new("kinstype.is-3", HAL_OUT, &(haldata->kinstype_is_3), comp_id);

    // define default kinematics at startup for switchable kinematics
    *haldata->kinstype_is_0 = 1; //default at startup -> identity kinematics
    *haldata->kinstype_is_1 = 0; //-> XYZAB TCP TURNING
    *haldata->kinstype_is_2 = 0; //-> XYZAB TCP MILLING
    *haldata->kinstype_is_3 = 0; //-> XYZAB TOOL


    if (res) goto error;
    hal_ready(comp_id);
    rtapi_print("*** %s setup ok\n",__FILE__);
    return 0;
error:
    rtapi_print("\n!!! %s setup failed res=%d\n\n",__FILE__,res);
    return -1;
	#undef HAL_PREFIX
}

EXPORT_SYMBOL(kinematicsType);
EXPORT_SYMBOL(kinematicsSwitchable);
EXPORT_SYMBOL(kinematicsSwitch);
EXPORT_SYMBOL(kinematicsInverse);
EXPORT_SYMBOL(kinematicsForward);

static hal_u32_t switchkins_type;

int kinematicsSwitchable() {return 1;}

int kinematicsSwitch(int new_switchkins_type)
{
    switchkins_type = new_switchkins_type;
    rtapi_print("kinematicsSwitch(): type=%d\n",switchkins_type);
    // create case structure for switchable kinematics
    switch (switchkins_type)
    {
        case 0: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE0\n");
                *haldata->kinstype_is_0 = 1;
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_2 = 0;
                *haldata->kinstype_is_3 = 0;
                break;
        case 1: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE1\n");
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_1 = 1;
                *haldata->kinstype_is_2 = 0;
                *haldata->kinstype_is_3 = 0;
                break;
        case 2: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE1\n");
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_2 = 1;
                *haldata->kinstype_is_3 = 0;
                break;
        case 3: rtapi_print_msg(RTAPI_MSG_INFO,
                "kinematicsSwitch:TYPE1\n");
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_2 = 0;
                *haldata->kinstype_is_3 = 1;
                break;
       default: rtapi_print_msg(RTAPI_MSG_ERR,
                "kinematicsSwitch:BAD VALUE <%d>\n", switchkins_type);
                *haldata->kinstype_is_0 = 0;
                *haldata->kinstype_is_1 = 0;
                *haldata->kinstype_is_2 = 0;
                *haldata->kinstype_is_3 = 0;
                return -1; // FAIL
    }
    return 0; // ok
}

KINEMATICS_TYPE kinematicsType()
{
	static bool is_setup=0;
    if (!is_setup)  MAZAK_setup();
    return KINEMATICS_BOTH; // set as required
    // Note: If kinematics are identity, using KINEMATICS_BOTH
    //       may be used in order to allow a gui to display
    //       joint values in preview prior to homing
} 

int kinematicsForward(const double *j, EmcPose * pos, const KINEMATICS_FORWARD_FLAGS * fflags, KINEMATICS_INVERSE_FLAGS * iflags)
{
    double y_yt_angle = *(haldata->y_yt_angle) * PM_PI / 180.0;

    double Drax = *(haldata->x_rot_axis);
    double Dray = *(haldata->y_rot_axis);

    double Lx = *(haldata->x_pivot);
    double Dz = *(haldata->z_offset);
    double Dtx = *(haldata->tool_offset_x);
    double Dty = *(haldata->tool_offset_y);
    double Dtz = *(haldata->tool_offset_z);
    double b_orientation = *(haldata->b_orientation);
    double tool_angle = *(haldata->tool_angle);
    double work_angle = *(haldata->work_angle);
    double prerot_angle = *(haldata->prerot_angle);

    double Lz =  Lx;
    double Dx = -Dz;

    double St  = 0;
    double Ct  = 0;
    double Sw  = 0;
    double Cw  = 0;
    double Stc = 0;
    double Ctc = 0;

    double Px   =  0;
    double Py   =  0;
    double Pz   =  0;
    double Qx   =  0;
    double Qy   =  0;
    double Qz   =  0;



    // define forward kinematic models using case structure for
    // for switchable kinematics
    switch (switchkins_type) 
    {
        case 0: // ====================== IDENTITY kinematics FORWARD ====================
            pos->tran.x =   (j[0] - Lx) - j[1] * cos(y_yt_angle);
            pos->tran.y =   j[1] * sin(y_yt_angle);
            pos->tran.z =   j[2] - Dz;
            pos->b      =   j[3];
            pos->c      =   j[4];
            // unused coordinates:
			pos->a = 0;
			pos->u = 0;
			pos->v = 0;
			pos->w = 0;

            break;

        case 1: // ================   LATHE    ========= TCP kinematics FORWARD ======================
            // substitutions as used in mathematical documentation
            St = sin((j[3])*TO_RAD);
            Ct = cos((j[3])*TO_RAD);
            Sw = 0; // no need to track the work rotation here
            Cw = 1; // no need to track the work rotation here
            Stc = sin(tool_angle*TO_RAD);
            Ctc = cos(tool_angle*TO_RAD);

            Px   =  (j[0]) - j[1] * cos(y_yt_angle);
            Py   =  j[1]        * sin(y_yt_angle);
            Pz   =  j[2];

            Qx =  -Ct*Cw*(Dtx + Lx) - Cw*Dz*St - (Cw*St*Stc - Ctc*Sw)*Dty - (Ctc*Cw*St + Stc*Sw)*Dtz + Cw*Px - Py*Sw + Dtx + Lx ;
            Qy =  -Ct*(Dtx + Lx)*Sw - Dz*St*Sw - (St*Stc*Sw + Ctc*Cw)*Dty - (Ctc*St*Sw - Cw*Stc)*Dtz + Cw*Py + Px*Sw + Dty ;
            Qz =  -Ct*Ctc*Dtz - Ct*Dty*Stc - Ct*Dz + (Dtx + Lx)*St + Dtz + Dz + Pz ;

            pos->tran.x = Qx - Lx;
            pos->tran.y = Qy;
            pos->tran.z = Qz - Dz;

            pos->b      = j[3];
            pos->c      = j[4];

            // unused coordinates:
			pos->a = 0;
			pos->u = 0;
			pos->v = 0;
			pos->w = 0;

            break;

        case 2: // ================   MILL   ========= TCP kinematics FORWARD ======================
            // substitutions as used in mathematical documentation
            St = sin((j[3]+90)*TO_RAD);
            Ct = cos((j[3]+90)*TO_RAD);
            Sw = sin(j[4]*TO_RAD);
            Cw = cos(j[4]*TO_RAD);
            Stc = sin(tool_angle*TO_RAD);
            Ctc = cos(tool_angle*TO_RAD);



            Px   =  (j[0]) - j[1] * cos(y_yt_angle);
            Py   =  j[1]          * sin(y_yt_angle);
            Pz   =  j[2];

            Qx =  -Ct*Cw*Dx - Cw*(Dtz + Lz)*St - (Ct*Ctc*Cw - Stc*Sw)*Dtx + (Ct*Cw*Stc + Ctc*Sw)*Dty + Cw*Px - Py*Sw + Dtx + Dx ;
            Qy =  -Ct*Dx*Sw - (Dtz + Lz)*St*Sw - (Ct*Ctc*Sw + Cw*Stc)*Dtx + (Ct*Stc*Sw - Ctc*Cw)*Dty + Cw*Py + Px*Sw + Dty ;
            Qz =  Ctc*Dtx*St - Dty*St*Stc - Ct*(Dtz + Lz) + Dx*St + Dtz + Lz + Pz ;

            pos->tran.x = Qx + Dz;
            pos->tran.y = Qy;
            pos->tran.z = Qz - Lx;

            pos->b      = j[3];
            pos->c      = j[4];

            // unused coordinates:
			pos->a = 0;
			pos->u = 0;
			pos->v = 0;
			pos->w = 0;

            break;

      case 3: // ========================= TWP kinematics FORWARD 
            // in TWP kinematics we use the articulated joint positions from the TWP
            St = sin(b_orientation);
            Ct = cos(b_orientation);
            Stc = sin(prerot_angle);
            Ctc = cos(prerot_angle);

            Px   =  j[0] - j[1] * cos(y_yt_angle) - Drax;
            Py   =  j[1]        * sin(y_yt_angle) - Dray;
            Pz   =  j[2];


            pos->tran.x =  Ct*Ctc*Px - Ctc*Pz*St + Py*Stc + Ctc*Dz ;
            pos->tran.y =  -Ct*Px*Stc + Pz*St*Stc + Ctc*Py - Stc*Dz;
            pos->tran.z =  Ct*Pz + Px*St - Lx;

            pos->b      = j[3];
            pos->c      = j[4];

            // unused coordinates:
			pos->a = 0;
			pos->u = 0;
			pos->v = 0;
			pos->w = 0;

            break;
    }
	return 0;
}

int kinematicsInverse(const EmcPose * pos, double *j, const KINEMATICS_INVERSE_FLAGS * iflags, KINEMATICS_FORWARD_FLAGS * fflags)
{
    double y_yt_angle = *(haldata->y_yt_angle) * PM_PI / 180.0;

    double Drax = *(haldata->x_rot_axis);
    double Dray = *(haldata->y_rot_axis);

    double Lx = *(haldata->x_pivot);
    double Dz = *(haldata->z_offset);
    double Dtx = *(haldata->tool_offset_x);
    double Dty = *(haldata->tool_offset_y);
    double Dtz = *(haldata->tool_offset_z);
    double b_orientation = *(haldata->b_orientation);
    double tool_angle = *(haldata->tool_angle);
    double work_angle = *(haldata->work_angle);
    double prerot_angle = *(haldata->prerot_angle);

    double Lz =  Lx;
    double Dx = -Dz;

    double St  = 0;
    double Ct  = 0;
    double Sw  = 0;
    double Cw  = 0;
    double Stc = 0;
    double Ctc = 0;

    double Px   =  0;
    double Py   =  0;
    double Pz   =  0;
    double Qx   =  0;
    double Qy   =  0;
    double Qz   =  0;

    switch (switchkins_type) 
    {
        case 0:// ====================== IDENTITY kinematics INVERSE =====================

            j[0] = pos->tran.x + pos->tran.y / tan(y_yt_angle) + Lx;
            j[1] = pos->tran.y / sin(y_yt_angle);
            j[2] = pos->tran.z + Dz;
            j[3] = pos->b;
            j[4] = pos->c;
            // unused coordinates:
            j[5] = 0;
			j[6] = 0;
			j[7] = 0;
			j[8] = 0;

            break;
        case 1: // ============   LATHE    ============= TCP kinematics INVERSE ======================
            // substitutions as used in mathematical documentation
            St = sin((j[3])*TO_RAD);
            Ct = cos((j[3])*TO_RAD);
            Sw = 0; // no need to track the work rotation here
            Cw = 1; // no need to track the work rotation here
            Stc = sin(tool_angle*TO_RAD);
            Ctc = cos(tool_angle*TO_RAD);

            Qx  =  pos->tran.x + Lx;
            Qy  =  pos->tran.y;
            Qz  =  pos->tran.z + Dz;

            Px =  Ctc*Dtz*St + Dty*St*Stc + Ct*Dtx + Ct*Lx + Dz*St - Cw*(Dtx + Lx - Qx) - (Dty - Qy)*Sw ;
            Py =  Ctc*Dty - Dtz*Stc - Cw*(Dty - Qy) + (Dtx + Lx - Qx)*Sw ;
            Pz =  Ct*Ctc*Dtz + Ct*Dty*Stc + Ct*Dz - Dtx*St - Lx*St - Dtz - Dz + Qz ;

            j[0] =    Px + Py / tan(y_yt_angle);
            j[1] =    Py / sin(y_yt_angle);
            j[2] =    Pz;

            j[3] = pos->b;
            j[4] = pos->c;

            // unused coordinates:
            j[5] = 0.0;
			j[6] = 0.0;
			j[7] = 0.0;
			j[8] = 0.0;

            break;

        case 2: // ============    MILL    ============= TCP kinematics INVERSE ======================
            // substitutions as used in mathematical documentation
            St = sin((j[3]+90)*TO_RAD);
            Ct = cos((j[3]+90)*TO_RAD);
            Sw = sin(j[4]*TO_RAD);
            Cw = cos(j[4]*TO_RAD);
            Stc = sin(tool_angle*TO_RAD);
            Ctc = cos(tool_angle*TO_RAD);

            Qx  =  pos->tran.x - Dz;
            Qy  =  pos->tran.y;
            Qz  =  pos->tran.z + Lx;



            Px =  Ct*Ctc*Dtx - Ct*Dty*Stc + Ct*Dx + Dtz*St + Lz*St - Cw*(Dtx + Dx - Qx) - (Dty - Qy)*Sw ;
            Py =  Ctc*Dty + Dtx*Stc - Cw*(Dty - Qy) + (Dtx + Dx - Qx)*Sw ;
            Pz =  -Ctc*Dtx*St + Dty*St*Stc + Ct*Dtz + Ct*Lz - Dx*St - Dtz - Lz + Qz ;

            if (y_yt_angle + 0.1> PM_PI / 2) {
                j[0] =    Px;
                j[1] =    Py;
            } else {
                j[0] =    Px + Py / tan(y_yt_angle);
                j[1] =    Py / sin(y_yt_angle);
            }

            j[2] =    Pz;

            j[3] = pos->b;
            j[4] = pos->c;

            // unused coordinates:
            j[5] = 0.0;
			j[6] = 0.0;
			j[7] = 0.0;
			j[8] = 0.0;

            break;

      case 3: // ========================= TWP kinematics INVERSE =========================
            // in TWP kinematics we use the articulated joint positions from the TWP
            St = sin(b_orientation);
            Ct = cos(b_orientation);
            Stc = sin(prerot_angle);
            Ctc = cos(prerot_angle);

            Qx =  pos->tran.x - Drax - Ctc*Dz;
            Qy =  pos->tran.y - Dray + Stc*Dz;
            Qz =  pos->tran.z + Lx;

            Px =  Ct*Ctc*Qx - Ct*Qy*Stc + Qz*St ;
            Py =  Ctc*Qy + Qx*Stc ;
            Pz =  -Ctc*Qx*St + Qy*St*Stc + Ct*Qz;

            j[0] =    (Px+Drax) + (Py+Dray) / tan(y_yt_angle);
            j[1] =    (Py+Dray) / sin(y_yt_angle);
            j[2] =    Pz;

            j[3] = pos->b;
            j[4] = pos->c;

            // unused coordinates:
            j[5] = 0.0;
			j[6] = 0.0;
			j[7] = 0.0;
			j[8] = 0.0;

            break;
    }
    return 0;
}
